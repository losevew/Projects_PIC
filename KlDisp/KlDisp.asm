;***********************************************************************************************
; KLDisp.asm
; Проверка вывода с клавиытуры на индикатор.
; PIC16F84A      Кварц 4 мГц.
;===============================================================================================
            LIST        p=16F84A    ; Установка типа микроконтроллера.
            __CONFIG    03FF1H      ; Бит защиты выключен, WDT выключен, 
                                    ; стандартный XT - генератор.
            include "p16f84a.inc"
;===============================================================================================
; Определение  названия  и  положения  регистров  общего  назначения.
;===============================================================================================
KEY_COUNT   equ h'20'
PATTERN     equ h'21'
COUNT       equ h'22'
NEW_KEY     equ h'23' 
OLD_KEY     equ h'24'
DATA_OUT    equ h'25'
TEMP        equ h'26'
COUNT2      equ h'27'

SDO         equ 0 
SCK         equ 1


; Определение точки входа в программу.
;=============================================================================================
            org        0           ; Начать выполнение программы
            goto       START       ; с первой команды подпрограммы START.
;*********************************************************************************************

;------------------------------- РАБОЧАЯ  ЧАСТЬ  ПРОГРАММЫ -----------------------------------
;*********************************************************************************************
; Подготовительные операции.
;---------------------------------------------------------------------------------------------

START       bsf	        STATUS,RP0	;	Переключаемся на 1-й банк памяти,
                                    ;	в котором расположены
            movlw	    b'11110000'	;	регистры TRISB и OPTION_REG
            movwf	    TRISB   	;	RB[7:4] - входы, RB[3:0] - выходы
            movlw	    b'00000000' ;
            movwf       TRISA       ;
            bcf	        OPTION_REG,NOT_RBPU	;	Включаем внутреннюю подтяжку
            bcf	        STATUS,RP0	;	Возвращаемся в 0-й банк
            bcf	        PORTA,SCK
            bcf	        PORTA,SDO
            movlw       0           ;   помещаем 0 в рабочий регистр
            movwf       DATA_OUT    ;   и выводим его в три разряда индикатора
            call        SPI_WRITE   ;   тем самым
            call        SPI_WRITE   ;   очищая его
            call        SPI_WRITE

OPROS       clrf        DATA_OUT
            call        GET_IT      ;   опрашиваем клавиатуру
            movwf       TEMP
            incf        TEMP,F
            btfsc       STATUS,Z    ;   проверяем нажата какая нибудь клавиша
            goto        OPROS       ;   если нет то повторяем опрос клавиатуры
            movwf       TEMP 
            addlw       -d'12'      ;   проверяем нажата ли клавиша SET
            btfsc       STATUS,Z    ;   если нажата 
            goto        START       ;   то переходим к началу программы
            movf        TEMP,W
            addlw       -d'11'      ;   проверяем нажата ли клавиша 0
            btfsc       STATUS,Z    ;   если нажата 
            goto        M1          ;   то переходим к M1
            movf        TEMP,W      ;
            movwf       DATA_OUT    ;   иначе, выводим число на индикацию
            call        SPI_WRITE   ;   и переходим к  задержке и опросу клавиатуры
            goto        OPROS

M1          movlw       0           ;   помещаем 0 в рабочий регистр
            movwf       DATA_OUT    ;   и выводим его в разряд индикатора
            call        SPI_WRITE 
            goto        OPROS 

;*************************************************************************
;	* ФУНКЦИЯ	:	Сканирует клавиатуру 4 х 3 и возвращает номер клавиши *
;	* ВХОД	:	Нет	                                                      *
;	* ВЫХОД	:	Номер клавиши в W ([MEM]=10, [0]=11, [SET]=12)            *
;	* ВЫХОД	:	Возвращает -1 (h'FF') если не нажато ни одной клавиши     *
;   * ОКРУЖЕНИЕ : Переменные KEY_COUNT, PATTERN                           *
;**************************************************************************

           
SCAN_IT    clrf        KEY_COUNT    ;	Первая клавиша - "1" 
           incf        KEY_COUNT,F
           movlw       b'11111110'	;	Начальное значение шаблона 
           movwf       PATTERN
           
SLOOP      movf        PATTERN,W   	;	Считываем шаблон из памяти
           movwf       PORTB        ;	Выдаем на строку НИЗКИЙ уровень
; Теперь проверяем каждый столбец	на наличие нуля 	
           btfss       PORTB,4	    ;	Проверяем 1-й столбец
           goto        GOT_IT	    ;	ЕСЛИ ноль, ТО клавиша обнаружена!
           incf        KEY_COUNT,F	;	ИНАЧЕ инкрементируем счетчик
           btfss       PORTB,5	    ;	Проверяем 2-й столбец
           goto        GOT_IT	    ;	ЕСЛИ ноль, ТО клавиша обнаружена!
           incf        KEY_COUNT,F  ;	ИНАЧЕ инкрементируем счетчик
     	   btfss       PORTB,6	    ;	Проверяем 3-й столбец
    	   goto        GOT_IT	    ;	ЕСЛИ ноль, ТО клавиша обнаружена!
	       incf        KEY_COUNT,F  ;	ИНАЧЕ инкрементируем счетчик
; Сюда попадаем, если нет нажатых клавиш 	
    	   rlf         PATTERN,F   	;   Сдвигаем шаблон
	       btfsc       PATTERN,4   	;   Появился ли 0 в 4-м бите?
	       goto        SLOOP	    ;   ЕСЛИ нет, ТО переходим к следующей строке
; ИНАЧЕ на клавиатуре нет нажатых клавиш 	
	       movlw       -1         	;   Возвращаем -1
	       goto        S_EXIT
GOT_IT     movf        KEY_COUNT,W 	;   Копируем значение счетчика в W
S_EXIT     return                   ;   и выходим


;****************************************************************************
;	* ФУНКЦИЯ	:	Сканирует клавиатуру 4 х 3 и возвращает номер клавиши	*
;	* ФУНКЦИЯ	:	(имеется защита от дребезга)                        	*
;	* ВХОД	:	Нет                                                     	*
;	* ВЫХОД	:	Номер клавиши в W ([MEM]=10, [0]=11, [SET]=12)          	*
;	* ВЫХОД	:	Возвращает -1 (h'FF')/ если не нажато ни одной клавиши  	*
;	* ОКРУЖЕНИЕ	:	Переменные COUNT, NEW_KEY, OLD_KEY                  	*
;	* ОКРУЖЕНИЕ	:	Подпрограмма SCAN__IT                                	*
;****************************************************************************
		  
GET_IT    clrf         COUNT       ;   Обнуляем счетчик
          movlw        d'0'        ;   присваиваем начальное
          movwf        COUNT       ;   значение счетчику
GLOOP     call         SCAN_IT	   ;   «Сырое» значение находится в W
	      movwf        NEW_KEY     ;   Сохраняем новое значение
          subwf        OLD_KEY,W   ;   Отличается от предыдущего?
          btfsc        STATUS ,Z
          goto         EQUAL	   ;   ЕСЛИ одинаковы, TO переходим к EQUAL
; Результат отличается от предыдущего, поэтому: 	
          movf         NEW_KEY,W   ;   Переписываем предыдущее значение новым
          movwf        OLD_KEY 
          goto         GET_IT	   ;   и начинаем цикл опроса сначала
; ЕСЛИ значения одинаковы, ТО 
EQUAL     incfsz       COUNT,F	   ;   Инкрементируем счетчик. ЕСЛИ нет
          goto         GLOOP       ;   переполнения, считываем новое значение
          movf         OLD_KEY,W   ;   ИНАЧЕ возвращаем требуемое значение! 
          return


; ******************************************************
; * ФУНКЦИЯ : Побитно передает байт данных, начиная со * 
; *	старшего бита                                      *
; * ВХОД : Байт данных в DATA_OUT                      *
; * ВЫХОД : DATA_OUT обнуляется                        *
; ******************************************************
; Задача 1 
SPI_WRITE  bcf	      PORTA,SCK   ;   В режиме ожидания на линии SCK - НИЗКИЙ уровень 
; Задача 2
           movlw      4           ;   Инициализируем счетчик цикла
           movwf      COUNT
; Задача 3, а и 3, б
LOOP       bcf        PORTA,SDO   ;   Выставляем на линию данных 0
           btfsc      DATA_OUT,3  ;   Пропускаем, ЕСЛИ старший бит = 0
           bsf        PORTA,SDO   ;   ИНАЧЕ выставляем на линию данных 1
           rlf        DATA_OUT,F  ;   Сдвигаем байт данных на один бит влево 
; Задача 3, в
           bsf        PORTA,SCK   ;   Формируем тактовый импульс
           nop
           nop
           bcf        PORTA,SCK 
; Задача 3, г
           decfsz     COUNT,F     ;   Декрементируем счетчик
           goto       LOOP        ;   и повторяем, пока он не станет равным 0
           bcf	      PORTA,SDO
           call       DELAY
           return

; ******************************************************
; * ФУНКЦИЯ : Формирование задержки                    * 
; ******************************************************

DELAY      movlw      128         ;   Инициализируем счетчик внешнего цикла 
           movwf      COUNT
M2         movlw      255         ;   Инициализируем счетчик внутреннего цикла 
           movwf      COUNT2
M3         nop
           nop
           nop
           decfsz     COUNT2,F    ;   Декрементируем счетчик 2
           goto       M3          ;   и повторяем, пока он не станет равным 0
           decfsz     COUNT,F     ;   Декрементируем счетчик 1
           goto       M2          ;   и повторяем, пока он не станет равным 0
           return

           end