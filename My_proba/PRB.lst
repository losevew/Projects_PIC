CCS PCM C Compiler, Version 5.019, 5967               29-џэт-16 21:34

               Filename:   D:\Projects PIC\My_proba\PRB.lst

               ROM used:   1393 words (34%)
                           Largest free fragment is 2048
               RAM used:   30 (16%) at main() level
                           65 (34%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   4B6
0003:  NOP
0004:  BTFSS  0A.3
0005:  BCF    0A.4
0006:  BTFSC  0A.3
0007:  BSF    0A.4
0008:  BCF    0A.3
0009:  BTFSC  03.5
000A:  GOTO   00F
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  GOTO   014
000F:  BCF    03.5
0010:  MOVWF  24
0011:  SWAPF  03,W
0012:  MOVWF  25
0013:  BSF    25.1
0014:  BTFSS  0A.4
0015:  BCF    0A.3
0016:  BTFSC  0A.4
0017:  BSF    0A.3
0018:  BCF    0A.4
0019:  MOVF   0A,W
001A:  MOVWF  2B
001B:  CLRF   0A
001C:  BCF    03.7
001D:  SWAPF  24,F
001E:  MOVF   04,W
001F:  MOVWF  26
0020:  MOVF   20,W
0021:  MOVWF  27
0022:  MOVF   21,W
0023:  MOVWF  28
0024:  MOVF   22,W
0025:  MOVWF  29
0026:  MOVF   23,W
0027:  MOVWF  2A
0028:  BCF    03.5
0029:  MOVLW  8C
002A:  MOVWF  04
002B:  BTFSS  00.1
002C:  GOTO   02F
002D:  BTFSC  0C.1
002E:  GOTO   042
002F:  MOVF   26,W
0030:  MOVWF  04
0031:  MOVF   27,W
0032:  MOVWF  20
0033:  MOVF   28,W
0034:  MOVWF  21
0035:  MOVF   29,W
0036:  MOVWF  22
0037:  MOVF   2A,W
0038:  MOVWF  23
0039:  MOVF   2B,W
003A:  MOVWF  0A
003B:  SWAPF  25,W
003C:  MOVWF  03
003D:  BCF    03.5
003E:  SWAPF  24,W
003F:  BTFSC  25.1
0040:  BSF    03.5
0041:  RETFIE
0042:  BCF    0A.3
0043:  GOTO   0C7
.................... #include <PRB.h> 
.................... #include <16C73B.h> 
.................... //////////// Standard Header file for the PIC16C73B device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16C73B 
0044:  BCF    0A.0
0045:  BCF    0A.1
0046:  BCF    0A.2
0047:  ADDWF  02,F
0048:  RETLW  0C
0049:  RETLW  00
004A:  BCF    0A.0
004B:  BCF    0A.1
004C:  BCF    0A.2
004D:  ADDWF  02,F
004E:  RETLW  53
004F:  RETLW  65
0050:  RETLW  6C
0051:  RETLW  65
0052:  RETLW  63
0053:  RETLW  74
0054:  RETLW  20
0055:  RETLW  6E
0056:  RETLW  75
0057:  RETLW  6D
0058:  RETLW  20
0059:  RETLW  3D
005A:  RETLW  20
005B:  RETLW  00
005C:  BCF    0A.0
005D:  BCF    0A.1
005E:  BCF    0A.2
005F:  ADDWF  02,F
0060:  RETLW  57
0061:  RETLW  72
0062:  RETLW  69
0063:  RETLW  74
0064:  RETLW  65
0065:  RETLW  20
0066:  RETLW  6E
0067:  RETLW  75
0068:  RETLW  6D
0069:  RETLW  20
006A:  RETLW  3D
006B:  RETLW  20
006C:  RETLW  00
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  52
0072:  RETLW  65
0073:  RETLW  61
0074:  RETLW  64
0075:  RETLW  20
0076:  RETLW  6E
0077:  RETLW  75
0078:  RETLW  6D
0079:  RETLW  20
007A:  RETLW  3D
007B:  RETLW  20
007C:  RETLW  00
*
00BF:  BCF    0A.0
00C0:  BCF    0A.1
00C1:  BCF    0A.2
00C2:  ADDWF  02,F
00C3:  GOTO   096
00C4:  GOTO   09E
00C5:  GOTO   08E
00C6:  GOTO   0A6
*
01B9:  BTFSC  03.1
01BA:  GOTO   1BD
01BB:  MOVLW  5A
01BC:  MOVWF  04
01BD:  MOVF   55,W
01BE:  XORWF  59,W
01BF:  ANDLW  80
01C0:  MOVWF  5F
01C1:  BTFSS  55.7
01C2:  GOTO   1CE
01C3:  COMF   52,F
01C4:  COMF   53,F
01C5:  COMF   54,F
01C6:  COMF   55,F
01C7:  INCF   52,F
01C8:  BTFSC  03.2
01C9:  INCF   53,F
01CA:  BTFSC  03.2
01CB:  INCF   54,F
01CC:  BTFSC  03.2
01CD:  INCF   55,F
01CE:  BTFSS  59.7
01CF:  GOTO   1DB
01D0:  COMF   56,F
01D1:  COMF   57,F
01D2:  COMF   58,F
01D3:  COMF   59,F
01D4:  INCF   56,F
01D5:  BTFSC  03.2
01D6:  INCF   57,F
01D7:  BTFSC  03.2
01D8:  INCF   58,F
01D9:  BTFSC  03.2
01DA:  INCF   59,F
01DB:  CLRF   20
01DC:  CLRF   21
01DD:  CLRF   22
01DE:  CLRF   23
01DF:  CLRF   5A
01E0:  CLRF   5B
01E1:  CLRF   5C
01E2:  CLRF   5D
01E3:  MOVF   59,W
01E4:  IORWF  58,W
01E5:  IORWF  57,W
01E6:  IORWF  56,W
01E7:  BTFSC  03.2
01E8:  GOTO   219
01E9:  MOVLW  20
01EA:  MOVWF  5E
01EB:  BCF    03.0
01EC:  RLF    52,F
01ED:  RLF    53,F
01EE:  RLF    54,F
01EF:  RLF    55,F
01F0:  RLF    5A,F
01F1:  RLF    5B,F
01F2:  RLF    5C,F
01F3:  RLF    5D,F
01F4:  MOVF   59,W
01F5:  SUBWF  5D,W
01F6:  BTFSS  03.2
01F7:  GOTO   202
01F8:  MOVF   58,W
01F9:  SUBWF  5C,W
01FA:  BTFSS  03.2
01FB:  GOTO   202
01FC:  MOVF   57,W
01FD:  SUBWF  5B,W
01FE:  BTFSS  03.2
01FF:  GOTO   202
0200:  MOVF   56,W
0201:  SUBWF  5A,W
0202:  BTFSS  03.0
0203:  GOTO   213
0204:  MOVF   56,W
0205:  SUBWF  5A,F
0206:  MOVF   57,W
0207:  BTFSS  03.0
0208:  INCFSZ 57,W
0209:  SUBWF  5B,F
020A:  MOVF   58,W
020B:  BTFSS  03.0
020C:  INCFSZ 58,W
020D:  SUBWF  5C,F
020E:  MOVF   59,W
020F:  BTFSS  03.0
0210:  INCFSZ 59,W
0211:  SUBWF  5D,F
0212:  BSF    03.0
0213:  RLF    20,F
0214:  RLF    21,F
0215:  RLF    22,F
0216:  RLF    23,F
0217:  DECFSZ 5E,F
0218:  GOTO   1EB
0219:  BTFSS  5F.7
021A:  GOTO   226
021B:  COMF   20,F
021C:  COMF   21,F
021D:  COMF   22,F
021E:  COMF   23,F
021F:  INCF   20,F
0220:  BTFSC  03.2
0221:  INCF   21,F
0222:  BTFSC  03.2
0223:  INCF   22,F
0224:  BTFSC  03.2
0225:  INCF   23,F
0226:  MOVF   5A,W
0227:  MOVWF  00
0228:  INCF   04,F
0229:  MOVF   5B,W
022A:  MOVWF  00
022B:  INCF   04,F
022C:  MOVF   5C,W
022D:  MOVWF  00
022E:  INCF   04,F
022F:  MOVF   5D,W
0230:  MOVWF  00
0231:  RETURN
*
024A:  MOVLW  20
024B:  MOVWF  58
024C:  CLRF   54
024D:  CLRF   55
024E:  CLRF   56
024F:  CLRF   57
0250:  MOVF   4F,W
0251:  MOVWF  23
0252:  MOVF   4E,W
0253:  MOVWF  22
0254:  MOVF   4D,W
0255:  MOVWF  21
0256:  MOVF   4C,W
0257:  MOVWF  20
0258:  BCF    03.0
0259:  BTFSS  20.0
025A:  GOTO   269
025B:  MOVF   50,W
025C:  ADDWF  54,F
025D:  MOVF   51,W
025E:  BTFSC  03.0
025F:  INCFSZ 51,W
0260:  ADDWF  55,F
0261:  MOVF   52,W
0262:  BTFSC  03.0
0263:  INCFSZ 52,W
0264:  ADDWF  56,F
0265:  MOVF   53,W
0266:  BTFSC  03.0
0267:  INCFSZ 53,W
0268:  ADDWF  57,F
0269:  RRF    57,F
026A:  RRF    56,F
026B:  RRF    55,F
026C:  RRF    54,F
026D:  RRF    23,F
026E:  RRF    22,F
026F:  RRF    21,F
0270:  RRF    20,F
0271:  DECFSZ 58,F
0272:  GOTO   258
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
....................  
.................... #use delay(crystal=10000000) 
*
00D7:  MOVLW  42
00D8:  MOVWF  04
00D9:  MOVF   00,W
00DA:  BTFSC  03.2
00DB:  GOTO   0EA
00DC:  MOVLW  03
00DD:  MOVWF  21
00DE:  CLRF   20
00DF:  DECFSZ 20,F
00E0:  GOTO   0DF
00E1:  DECFSZ 21,F
00E2:  GOTO   0DE
00E3:  MOVLW  3C
00E4:  MOVWF  20
00E5:  DECFSZ 20,F
00E6:  GOTO   0E5
00E7:  GOTO   0E8
00E8:  DECFSZ 00,F
00E9:  GOTO   0DC
00EA:  RETURN
.................... //#use FIXED_IO( B_outputs=PIN_B3 ) 
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3) 
....................  
....................  
.................... #include <2465.C> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a MicroChip 24C65                                   //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);  Read the byte d from the address a     //// 
.................... ////                                                                   //// 
.................... ////   b = ext_eeprom_ready();  Returns TRUE if the eeprom is ready    //// 
.................... ////                            to receive opcodes                     //// 
.................... ////                                                                   //// 
.................... ////   The main program may define EEPROM_SDA                          //// 
.................... ////   and EEPROM_SCL to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... ////                            Pin Layout                             //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////   |                                                         |     //// 
.................... ////   | 1: NC   Not Connected | 8: VCC   +5V                    |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 2: NC   Not Connected | 7: NC    Not Connected          |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 3: NC   Not Connected | 6: SCL   EEPROM_SCL and Pull-Up |     //// 
.................... ////   |                       |                                 |     //// 
.................... ////   | 4: VSS  GND           | 5: SDA   EEPROM_SDA and Pull-Up |     //// 
.................... ////   -----------------------------------------------------------     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
....................  
.................... #endif 
....................  
....................  
.................... #define hi(x)  (*((int8 *)&x+1)) 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
033F:  MOVLW  08
0340:  MOVWF  21
0341:  NOP
0342:  BCF    07.3
0343:  BCF    2C.3
0344:  MOVF   2C,W
0345:  BSF    03.5
0346:  MOVWF  07
0347:  NOP
0348:  BCF    03.5
0349:  RLF    41,F
034A:  BCF    07.4
034B:  BTFSS  03.0
034C:  GOTO   353
034D:  BSF    2C.4
034E:  MOVF   2C,W
034F:  BSF    03.5
0350:  MOVWF  07
0351:  GOTO   357
0352:  BCF    03.5
0353:  BCF    2C.4
0354:  MOVF   2C,W
0355:  BSF    03.5
0356:  MOVWF  07
0357:  NOP
0358:  BCF    03.5
0359:  BSF    2C.3
035A:  MOVF   2C,W
035B:  BSF    03.5
035C:  MOVWF  07
035D:  BCF    03.5
035E:  BTFSS  07.3
035F:  GOTO   35E
0360:  DECFSZ 21,F
0361:  GOTO   341
0362:  NOP
0363:  BCF    07.3
0364:  BCF    2C.3
0365:  MOVF   2C,W
0366:  BSF    03.5
0367:  MOVWF  07
0368:  NOP
0369:  BCF    03.5
036A:  BSF    2C.4
036B:  MOVF   2C,W
036C:  BSF    03.5
036D:  MOVWF  07
036E:  NOP
036F:  NOP
0370:  BCF    03.5
0371:  BSF    2C.3
0372:  MOVF   2C,W
0373:  BSF    03.5
0374:  MOVWF  07
0375:  BCF    03.5
0376:  BTFSS  07.3
0377:  GOTO   376
0378:  CLRF   21
0379:  NOP
037A:  BTFSC  07.4
037B:  BSF    21.0
037C:  BCF    07.3
037D:  BCF    2C.3
037E:  MOVF   2C,W
037F:  BSF    03.5
0380:  MOVWF  07
0381:  BCF    03.5
0382:  BCF    07.4
0383:  BCF    2C.4
0384:  MOVF   2C,W
0385:  BSF    03.5
0386:  MOVWF  07
0387:  BCF    03.5
0388:  RETURN
*
0456:  MOVLW  08
0457:  MOVWF  41
0458:  MOVF   20,W
0459:  MOVWF  42
045A:  BSF    2C.4
045B:  MOVF   2C,W
045C:  BSF    03.5
045D:  MOVWF  07
045E:  NOP
045F:  BCF    03.5
0460:  BSF    2C.3
0461:  MOVF   2C,W
0462:  BSF    03.5
0463:  MOVWF  07
0464:  BCF    03.5
0465:  BTFSS  07.3
0466:  GOTO   465
0467:  BTFSC  07.4
0468:  BSF    03.0
0469:  BTFSS  07.4
046A:  BCF    03.0
046B:  RLF    21,F
046C:  NOP
046D:  BCF    2C.3
046E:  MOVF   2C,W
046F:  BSF    03.5
0470:  MOVWF  07
0471:  BCF    03.5
0472:  BCF    07.3
0473:  DECFSZ 41,F
0474:  GOTO   45A
0475:  BSF    2C.4
0476:  MOVF   2C,W
0477:  BSF    03.5
0478:  MOVWF  07
0479:  NOP
047A:  BCF    03.5
047B:  BCF    07.4
047C:  MOVF   42,W
047D:  BTFSC  03.2
047E:  GOTO   484
047F:  BCF    2C.4
0480:  MOVF   2C,W
0481:  BSF    03.5
0482:  MOVWF  07
0483:  BCF    03.5
0484:  NOP
0485:  BSF    2C.3
0486:  MOVF   2C,W
0487:  BSF    03.5
0488:  MOVWF  07
0489:  BCF    03.5
048A:  BTFSS  07.3
048B:  GOTO   48A
048C:  NOP
048D:  BCF    07.3
048E:  BCF    2C.3
048F:  MOVF   2C,W
0490:  BSF    03.5
0491:  MOVWF  07
0492:  NOP
0493:  BCF    03.5
0494:  BCF    07.4
0495:  BCF    2C.4
0496:  MOVF   2C,W
0497:  BSF    03.5
0498:  MOVWF  07
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE    8192 
....................  
.................... void init_ext_eeprom() { 
....................    output_float(EEPROM_SCL); 
*
00CB:  BSF    2C.3
00CC:  MOVF   2C,W
00CD:  BSF    03.5
00CE:  MOVWF  07
....................    output_float(EEPROM_SDA); 
00CF:  BCF    03.5
00D0:  BSF    2C.4
00D1:  MOVF   2C,W
00D2:  BSF    03.5
00D3:  MOVWF  07
00D4:  BCF    03.5
00D5:  BCF    0A.3
00D6:  GOTO   4CC (RETURN)
.................... } 
....................  
.................... BOOLEAN ext_eeprom_ready() { 
....................    int1 ack; 
....................    i2c_start();            // If the write command is acknowledged, 
*
0389:  BSF    2C.4
038A:  MOVF   2C,W
038B:  BSF    03.5
038C:  MOVWF  07
038D:  NOP
038E:  BCF    03.5
038F:  BSF    2C.3
0390:  MOVF   2C,W
0391:  BSF    03.5
0392:  MOVWF  07
0393:  NOP
0394:  BCF    03.5
0395:  BCF    07.4
0396:  BCF    2C.4
0397:  MOVF   2C,W
0398:  BSF    03.5
0399:  MOVWF  07
039A:  NOP
039B:  BCF    03.5
039C:  BCF    07.3
039D:  BCF    2C.3
039E:  MOVF   2C,W
039F:  BSF    03.5
03A0:  MOVWF  07
....................    ack = i2c_write(0xa0);  // then the device is ready. 
03A1:  MOVLW  A0
03A2:  BCF    03.5
03A3:  MOVWF  41
03A4:  CALL   33F
03A5:  MOVF   21,W
03A6:  BCF    40.0
03A7:  BTFSC  21.0
03A8:  BSF    40.0
....................    i2c_stop(); 
03A9:  BCF    2C.4
03AA:  MOVF   2C,W
03AB:  BSF    03.5
03AC:  MOVWF  07
03AD:  NOP
03AE:  BCF    03.5
03AF:  BSF    2C.3
03B0:  MOVF   2C,W
03B1:  BSF    03.5
03B2:  MOVWF  07
03B3:  BCF    03.5
03B4:  BTFSS  07.3
03B5:  GOTO   3B4
03B6:  NOP
03B7:  GOTO   3B8
03B8:  NOP
03B9:  BSF    2C.4
03BA:  MOVF   2C,W
03BB:  BSF    03.5
03BC:  MOVWF  07
03BD:  NOP
....................    return !ack; 
03BE:  MOVLW  00
03BF:  BCF    03.5
03C0:  BTFSS  40.0
03C1:  MOVLW  01
03C2:  MOVWF  21
03C3:  RETURN
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) { 
....................    while(!ext_eeprom_ready()); 
03C4:  CALL   389
03C5:  MOVF   21,F
03C6:  BTFSC  03.2
03C7:  GOTO   3C4
....................    i2c_start(); 
03C8:  BSF    2C.4
03C9:  MOVF   2C,W
03CA:  BSF    03.5
03CB:  MOVWF  07
03CC:  NOP
03CD:  BCF    03.5
03CE:  BSF    2C.3
03CF:  MOVF   2C,W
03D0:  BSF    03.5
03D1:  MOVWF  07
03D2:  NOP
03D3:  BCF    03.5
03D4:  BCF    07.4
03D5:  BCF    2C.4
03D6:  MOVF   2C,W
03D7:  BSF    03.5
03D8:  MOVWF  07
03D9:  NOP
03DA:  BCF    03.5
03DB:  BCF    07.3
03DC:  BCF    2C.3
03DD:  MOVF   2C,W
03DE:  BSF    03.5
03DF:  MOVWF  07
....................    i2c_write(0xa0); 
03E0:  MOVLW  A0
03E1:  BCF    03.5
03E2:  MOVWF  41
03E3:  CALL   33F
....................    i2c_write(hi(address)); 
03E4:  MOVLW  3D
03E5:  MOVWF  40
03E6:  MOVLW  01
03E7:  ADDWF  40,W
03E8:  MOVWF  04
03E9:  MOVF   00,W
03EA:  MOVWF  40
03EB:  MOVWF  41
03EC:  CALL   33F
....................    i2c_write(address); 
03ED:  MOVF   3D,W
03EE:  MOVWF  41
03EF:  CALL   33F
....................    i2c_write(data); 
03F0:  MOVF   3F,W
03F1:  MOVWF  41
03F2:  CALL   33F
....................    i2c_stop(); 
03F3:  BCF    2C.4
03F4:  MOVF   2C,W
03F5:  BSF    03.5
03F6:  MOVWF  07
03F7:  NOP
03F8:  BCF    03.5
03F9:  BSF    2C.3
03FA:  MOVF   2C,W
03FB:  BSF    03.5
03FC:  MOVWF  07
03FD:  BCF    03.5
03FE:  BTFSS  07.3
03FF:  GOTO   3FE
0400:  NOP
0401:  GOTO   402
0402:  NOP
0403:  BSF    2C.4
0404:  MOVF   2C,W
0405:  BSF    03.5
0406:  MOVWF  07
0407:  NOP
0408:  BCF    03.5
0409:  BCF    0A.3
040A:  GOTO   4F3 (RETURN)
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................  
....................    while(!ext_eeprom_ready()); 
040B:  CALL   389
040C:  MOVF   21,F
040D:  BTFSC  03.2
040E:  GOTO   40B
....................    i2c_start(); 
040F:  BSF    2C.4
0410:  MOVF   2C,W
0411:  BSF    03.5
0412:  MOVWF  07
0413:  NOP
0414:  BCF    03.5
0415:  BSF    2C.3
0416:  MOVF   2C,W
0417:  BSF    03.5
0418:  MOVWF  07
0419:  NOP
041A:  BCF    03.5
041B:  BCF    07.4
041C:  BCF    2C.4
041D:  MOVF   2C,W
041E:  BSF    03.5
041F:  MOVWF  07
0420:  NOP
0421:  BCF    03.5
0422:  BCF    07.3
0423:  BCF    2C.3
0424:  MOVF   2C,W
0425:  BSF    03.5
0426:  MOVWF  07
....................    i2c_write(0xa0); 
0427:  MOVLW  A0
0428:  BCF    03.5
0429:  MOVWF  41
042A:  CALL   33F
....................    i2c_write(hi(address)); 
042B:  MOVLW  3D
042C:  MOVWF  40
042D:  MOVLW  01
042E:  ADDWF  40,W
042F:  MOVWF  04
0430:  MOVF   00,W
0431:  MOVWF  40
0432:  MOVWF  41
0433:  CALL   33F
....................    i2c_write(address); 
0434:  MOVF   3D,W
0435:  MOVWF  41
0436:  CALL   33F
....................    i2c_start(); 
0437:  BSF    2C.4
0438:  MOVF   2C,W
0439:  BSF    03.5
043A:  MOVWF  07
043B:  NOP
043C:  BCF    03.5
043D:  BSF    2C.3
043E:  MOVF   2C,W
043F:  BSF    03.5
0440:  MOVWF  07
0441:  NOP
0442:  BCF    03.5
0443:  BTFSS  07.3
0444:  GOTO   443
0445:  BCF    07.4
0446:  BCF    2C.4
0447:  MOVF   2C,W
0448:  BSF    03.5
0449:  MOVWF  07
044A:  NOP
044B:  BCF    03.5
044C:  BCF    07.3
044D:  BCF    2C.3
044E:  MOVF   2C,W
044F:  BSF    03.5
0450:  MOVWF  07
....................    i2c_write(0xa1); 
0451:  MOVLW  A1
0452:  BCF    03.5
0453:  MOVWF  41
0454:  CALL   33F
....................    data=i2c_read(0); 
0455:  CLRF   20
*
0499:  BCF    03.5
049A:  MOVF   21,W
049B:  MOVWF  3F
....................    i2c_stop(); 
049C:  BCF    2C.4
049D:  MOVF   2C,W
049E:  BSF    03.5
049F:  MOVWF  07
04A0:  NOP
04A1:  BCF    03.5
04A2:  BSF    2C.3
04A3:  MOVF   2C,W
04A4:  BSF    03.5
04A5:  MOVWF  07
04A6:  BCF    03.5
04A7:  BTFSS  07.3
04A8:  GOTO   4A7
04A9:  NOP
04AA:  GOTO   4AB
04AB:  NOP
04AC:  BSF    2C.4
04AD:  MOVF   2C,W
04AE:  BSF    03.5
04AF:  MOVWF  07
04B0:  NOP
....................    return(data); 
04B1:  BCF    03.5
04B2:  MOVF   3F,W
04B3:  MOVWF  21
04B4:  BCF    0A.3
04B5:  GOTO   556 (RETURN)
.................... } 
....................  
.................... #include <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0105:  MOVLW  0F
0106:  BSF    03.5
0107:  ANDWF  06,W
0108:  IORLW  F0
0109:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
010A:  BCF    03.5
010B:  BSF    06.2
....................    delay_cycles(1); 
010C:  NOP
....................    lcd_output_enable(1); 
010D:  BSF    06.0
....................    delay_cycles(1); 
010E:  NOP
....................    high = lcd_read_nibble(); 
010F:  CALL   0F9
0110:  MOVF   21,W
0111:  MOVWF  46
....................        
....................    lcd_output_enable(0); 
0112:  BCF    06.0
....................    delay_cycles(1); 
0113:  NOP
....................    lcd_output_enable(1); 
0114:  BSF    06.0
....................    delay_us(1); 
0115:  GOTO   116
....................    low = lcd_read_nibble(); 
0116:  CALL   0F9
0117:  MOVF   21,W
0118:  MOVWF  45
....................        
....................    lcd_output_enable(0); 
0119:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
011A:  MOVLW  0F
011B:  BSF    03.5
011C:  ANDWF  06,W
011D:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
011E:  BCF    03.5
011F:  SWAPF  46,W
0120:  MOVWF  20
0121:  MOVLW  F0
0122:  ANDWF  20,F
0123:  MOVF   20,W
0124:  IORWF  45,W
0125:  MOVWF  21
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00F9:  MOVF   06,W
00FA:  MOVWF  20
00FB:  SWAPF  06,W
00FC:  ANDLW  0F
00FD:  MOVWF  21
....................   #endif 
00FE:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00EB:  SWAPF  46,W
00EC:  ANDLW  F0
00ED:  MOVWF  20
00EE:  MOVLW  0F
00EF:  ANDWF  06,W
00F0:  IORWF  20,W
00F1:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
00F2:  NOP
....................    lcd_output_enable(1); 
00F3:  BSF    06.0
....................    delay_us(2); 
00F4:  GOTO   0F5
00F5:  GOTO   0F6
00F6:  NOP
....................    lcd_output_enable(0); 
00F7:  BCF    06.0
00F8:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00FF:  BSF    03.5
0100:  BCF    06.0
....................    lcd_rs_tris(); 
0101:  BCF    06.1
....................    lcd_rw_tris(); 
0102:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0103:  BCF    03.5
0104:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0126:  MOVF   21,W
0127:  MOVWF  45
0128:  BTFSC  45.7
0129:  GOTO   105
....................    lcd_output_rs(address); 
012A:  BTFSS  43.0
012B:  BCF    06.1
012C:  BTFSC  43.0
012D:  BSF    06.1
....................    delay_cycles(1); 
012E:  NOP
....................    lcd_output_rw(0); 
012F:  BCF    06.2
....................    delay_cycles(1); 
0130:  NOP
....................    lcd_output_enable(0); 
0131:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
0132:  SWAPF  44,W
0133:  MOVWF  45
0134:  MOVLW  0F
0135:  ANDWF  45,F
0136:  MOVF   45,W
0137:  MOVWF  46
0138:  CALL   0EB
....................    lcd_send_nibble(n & 0xf); 
0139:  MOVF   44,W
013A:  ANDLW  0F
013B:  MOVWF  45
013C:  MOVWF  46
013D:  CALL   0EB
013E:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
013F:  MOVLW  28
0140:  MOVWF  3E
0141:  MOVLW  0C
0142:  MOVWF  3F
0143:  MOVLW  01
0144:  MOVWF  40
0145:  MOVLW  06
0146:  MOVWF  41
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0147:  BCF    06.0
....................    lcd_output_rs(0); 
0148:  BCF    06.1
....................    lcd_output_rw(0); 
0149:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
014A:  MOVLW  0F
014B:  BSF    03.5
014C:  ANDWF  06,W
014D:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
014E:  BCF    06.0
....................    lcd_rs_tris(); 
014F:  BCF    06.1
....................    lcd_rw_tris(); 
0150:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
0151:  MOVLW  0F
0152:  BCF    03.5
0153:  MOVWF  42
0154:  CALL   0D7
....................    for(i=1;i<=3;++i) 
0155:  MOVLW  01
0156:  MOVWF  3D
0157:  MOVF   3D,W
0158:  SUBLW  03
0159:  BTFSS  03.0
015A:  GOTO   163
....................    { 
....................        lcd_send_nibble(3); 
015B:  MOVLW  03
015C:  MOVWF  46
015D:  CALL   0EB
....................        delay_ms(5); 
015E:  MOVLW  05
015F:  MOVWF  42
0160:  CALL   0D7
0161:  INCF   3D,F
0162:  GOTO   157
....................    } 
....................     
....................    lcd_send_nibble(2); 
0163:  MOVLW  02
0164:  MOVWF  46
0165:  CALL   0EB
....................    delay_ms(5); 
0166:  MOVLW  05
0167:  MOVWF  42
0168:  CALL   0D7
....................    for(i=0;i<=3;++i) 
0169:  CLRF   3D
016A:  MOVF   3D,W
016B:  SUBLW  03
016C:  BTFSS  03.0
016D:  GOTO   179
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
016E:  MOVLW  3E
016F:  ADDWF  3D,W
0170:  MOVWF  04
0171:  MOVF   00,W
0172:  MOVWF  42
0173:  CLRF   43
0174:  MOVF   42,W
0175:  MOVWF  44
0176:  CALL   0FF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0177:  INCF   3D,F
0178:  GOTO   16A
0179:  BCF    0A.3
017A:  GOTO   4D2 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
017B:  DECFSZ 40,W
017C:  GOTO   17E
017D:  GOTO   181
....................       address=LCD_LINE_TWO; 
017E:  MOVLW  40
017F:  MOVWF  41
0180:  GOTO   182
....................    else 
....................       address=0; 
0181:  CLRF   41
....................       
....................    address+=x-1; 
0182:  MOVLW  01
0183:  SUBWF  3F,W
0184:  ADDWF  41,F
....................    lcd_send_byte(0,0x80|address); 
0185:  MOVF   41,W
0186:  IORLW  80
0187:  MOVWF  42
0188:  CLRF   43
0189:  MOVF   42,W
018A:  MOVWF  44
018B:  CALL   0FF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
018C:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
018D:  MOVF   3E,W
018E:  XORLW  07
018F:  BTFSC  03.2
0190:  GOTO   19B
0191:  XORLW  0B
0192:  BTFSC  03.2
0193:  GOTO   1A0
0194:  XORLW  06
0195:  BTFSC  03.2
0196:  GOTO   1A8
0197:  XORLW  02
0198:  BTFSC  03.2
0199:  GOTO   1AE
019A:  GOTO   1B3
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
019B:  MOVLW  01
019C:  MOVWF  3F
019D:  MOVWF  40
019E:  CALL   17B
019F:  GOTO   1B8
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01A0:  CLRF   43
01A1:  MOVLW  01
01A2:  MOVWF  44
01A3:  CALL   0FF
....................                      delay_ms(2); 
01A4:  MOVLW  02
01A5:  MOVWF  42
01A6:  CALL   0D7
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01A7:  GOTO   1B8
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01A8:  MOVLW  01
01A9:  MOVWF  3F
01AA:  MOVLW  02
01AB:  MOVWF  40
01AC:  CALL   17B
01AD:  GOTO   1B8
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01AE:  CLRF   43
01AF:  MOVLW  10
01B0:  MOVWF  44
01B1:  CALL   0FF
01B2:  GOTO   1B8
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01B3:  MOVLW  01
01B4:  MOVWF  43
01B5:  MOVF   3E,W
01B6:  MOVWF  44
01B7:  CALL   0FF
....................      #endif 
....................    } 
01B8:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
04C1:  BCF    03.5
04C2:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0232:  CLRF   47
0233:  CLRF   46
0234:  CLRF   45
0235:  MOVLW  01
0236:  MOVWF  44
0237:  CLRF   49
0238:  CLRF   4A
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0239:  BTFSS  41.7
023A:  GOTO   27B
....................          sign=1;        // Check for negative number 
023B:  MOVLW  01
023C:  MOVWF  49
....................          num*=-1; 
023D:  MOVF   41,W
023E:  MOVWF  4F
023F:  MOVF   40,W
0240:  MOVWF  4E
0241:  MOVF   3F,W
0242:  MOVWF  4D
0243:  MOVF   3E,W
0244:  MOVWF  4C
0245:  MOVLW  FF
0246:  MOVWF  53
0247:  MOVWF  52
0248:  MOVWF  51
0249:  MOVWF  50
*
0273:  MOVF   23,W
0274:  MOVWF  41
0275:  MOVF   22,W
0276:  MOVWF  40
0277:  MOVF   21,W
0278:  MOVWF  3F
0279:  MOVF   20,W
027A:  MOVWF  3E
....................      } 
....................  
....................      while(temp>0) { 
027B:  MOVF   44,F
027C:  BTFSS  03.2
027D:  GOTO   287
027E:  MOVF   45,F
027F:  BTFSS  03.2
0280:  GOTO   287
0281:  MOVF   46,F
0282:  BTFSS  03.2
0283:  GOTO   287
0284:  MOVF   47,F
0285:  BTFSC  03.2
0286:  GOTO   2E6
....................          temp=(num/base); 
0287:  BCF    03.1
0288:  MOVF   41,W
0289:  MOVWF  55
028A:  MOVF   40,W
028B:  MOVWF  54
028C:  MOVF   3F,W
028D:  MOVWF  53
028E:  MOVF   3E,W
028F:  MOVWF  52
0290:  CLRF   59
0291:  CLRF   58
0292:  CLRF   57
0293:  MOVF   42,W
0294:  MOVWF  56
0295:  CALL   1B9
0296:  MOVF   23,W
0297:  MOVWF  47
0298:  MOVF   22,W
0299:  MOVWF  46
029A:  MOVF   21,W
029B:  MOVWF  45
029C:  MOVF   20,W
029D:  MOVWF  44
....................          s[cnt]=(num%base)+'0';    // Conversion 
029E:  MOVF   43,W
029F:  ADDWF  4A,W
02A0:  MOVWF  4C
02A1:  MOVF   04,W
02A2:  MOVWF  4D
02A3:  BSF    03.1
02A4:  MOVLW  4E
02A5:  MOVWF  04
02A6:  MOVF   41,W
02A7:  MOVWF  55
02A8:  MOVF   40,W
02A9:  MOVWF  54
02AA:  MOVF   3F,W
02AB:  MOVWF  53
02AC:  MOVF   3E,W
02AD:  MOVWF  52
02AE:  CLRF   59
02AF:  CLRF   58
02B0:  CLRF   57
02B1:  MOVF   42,W
02B2:  MOVWF  56
02B3:  CALL   1B9
02B4:  MOVF   4D,W
02B5:  MOVWF  04
02B6:  MOVLW  30
02B7:  ADDWF  4E,W
02B8:  MOVWF  20
02B9:  MOVF   4F,W
02BA:  MOVWF  21
02BB:  MOVLW  00
02BC:  BTFSC  03.0
02BD:  MOVLW  01
02BE:  ADDWF  21,F
02BF:  MOVF   50,W
02C0:  MOVWF  22
02C1:  MOVLW  00
02C2:  BTFSC  03.0
02C3:  MOVLW  01
02C4:  ADDWF  22,F
02C5:  MOVF   51,W
02C6:  MOVWF  23
02C7:  MOVLW  00
02C8:  BTFSC  03.0
02C9:  MOVLW  01
02CA:  ADDWF  23,F
02CB:  MOVF   4C,W
02CC:  MOVWF  04
02CD:  MOVF   20,W
02CE:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
02CF:  MOVF   43,W
02D0:  ADDWF  4A,W
02D1:  MOVWF  04
02D2:  MOVF   00,W
02D3:  SUBLW  39
02D4:  BTFSC  03.0
02D5:  GOTO   2DC
....................             s[cnt]+=0x7; 
02D6:  MOVF   43,W
02D7:  ADDWF  4A,W
02D8:  MOVWF  04
02D9:  MOVLW  07
02DA:  ADDWF  00,W
02DB:  MOVWF  00
....................  
....................          cnt++; 
02DC:  INCF   4A,F
....................          num=temp; 
02DD:  MOVF   47,W
02DE:  MOVWF  41
02DF:  MOVF   46,W
02E0:  MOVWF  40
02E1:  MOVF   45,W
02E2:  MOVWF  3F
02E3:  MOVF   44,W
02E4:  MOVWF  3E
02E5:  GOTO   27B
....................      } 
....................  
....................      if(sign==1) { 
02E6:  DECFSZ 49,W
02E7:  GOTO   2EE
....................          s[cnt]=0x2D;      // Negative sign 
02E8:  MOVF   43,W
02E9:  ADDWF  4A,W
02EA:  MOVWF  04
02EB:  MOVLW  2D
02EC:  MOVWF  00
....................          cnt++; 
02ED:  INCF   4A,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
02EE:  CLRF   48
02EF:  BCF    03.0
02F0:  RRF    4A,W
02F1:  SUBWF  48,W
02F2:  BTFSC  03.0
02F3:  GOTO   310
....................  
....................          c=s[i]; 
02F4:  MOVF   43,W
02F5:  ADDWF  48,W
02F6:  MOVWF  04
02F7:  MOVF   00,W
02F8:  MOVWF  4B
....................          s[i]=s[cnt-i-1];        // Reverse the number 
02F9:  MOVF   43,W
02FA:  ADDWF  48,W
02FB:  MOVWF  4C
02FC:  MOVF   48,W
02FD:  SUBWF  4A,W
02FE:  ADDLW  FF
02FF:  ADDWF  43,W
0300:  MOVWF  04
0301:  MOVF   00,W
0302:  MOVWF  4D
0303:  MOVF   4C,W
0304:  MOVWF  04
0305:  MOVF   4D,W
0306:  MOVWF  00
....................          s[cnt-i-1]=c; 
0307:  MOVF   48,W
0308:  SUBWF  4A,W
0309:  ADDLW  FF
030A:  ADDWF  43,W
030B:  MOVWF  04
030C:  MOVF   4B,W
030D:  MOVWF  00
030E:  INCF   48,F
030F:  GOTO   2EF
....................      } 
....................      s[cnt]='\0';     // End the string 
0310:  MOVF   43,W
0311:  ADDWF  4A,W
0312:  MOVWF  04
0313:  CLRF   00
....................      return s; 
0314:  MOVF   43,W
0315:  MOVWF  21
0316:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... unsigned char NewState, OldState, OldVol, upState, downState, OldBtnW, OldBtnR; 
.................... unsigned char Vol = 0x7F; 
.................... char Duty[3]; 
....................  
.................... void EncoderScan(void); 
.................... void LcdOut (void); 
....................  
....................  
.................... #INT_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    EncoderScan(); 
*
00C7:  GOTO   07D
....................        
.................... } 
....................  
.................... #define LCD_ENABLE_PIN PIN_B0 
.................... #define LCD_RS_PIN PIN_B1 
.................... #define LCD_RW_PIN PIN_B2 
.................... #define LCD_DATA4 PIN_B4 
.................... #define LCD_DATA5 PIN_B5 
.................... #define LCD_DATA6 PIN_B6 
00C8:  BCF    0C.1
00C9:  BCF    0A.3
00CA:  GOTO   02F
.................... #define LCD_DATA7 PIN_B7 
....................  
....................  
.................... void EncoderScan(void) 
.................... { 
....................     NewState = input_a() & 0x03;  
*
007D:  MOVLW  FF
007E:  BSF    03.5
007F:  MOVWF  05
0080:  BCF    03.5
0081:  MOVF   05,W
0082:  ANDLW  03
0083:  MOVWF  32
....................     if (NewState != OldState) {  
0084:  MOVF   33,W
0085:  SUBWF  32,W
0086:  BTFSC  03.2
0087:  GOTO   0BD
....................         switch (OldState) { 
0088:  MOVF   33,W
0089:  ADDLW  FC
008A:  BTFSC  03.0
008B:  GOTO   0AD
008C:  ADDLW  04
008D:  GOTO   0BF
....................             case 2: 
....................                 { 
....................                 if (NewState == 3)upState++; 
008E:  MOVF   32,W
008F:  SUBLW  03
0090:  BTFSC  03.2
0091:  INCF   35,F
....................                 if (NewState == 0)downState++; 
0092:  MOVF   32,F
0093:  BTFSC  03.2
0094:  INCF   36,F
....................                 break; 
0095:  GOTO   0AD
....................                 } 
....................             case 0: 
....................                 { 
....................                 if (NewState == 2)upState++; 
0096:  MOVF   32,W
0097:  SUBLW  02
0098:  BTFSC  03.2
0099:  INCF   35,F
....................                 if (NewState == 1)downState++;   
009A:  DECFSZ 32,W
009B:  GOTO   09D
009C:  INCF   36,F
....................                 break; 
009D:  GOTO   0AD
....................                 } 
....................             case 1: 
....................                 { 
....................                 if (NewState == 0)upState++; 
009E:  MOVF   32,F
009F:  BTFSC  03.2
00A0:  INCF   35,F
....................                 if (NewState == 3)downState++;  
00A1:  MOVF   32,W
00A2:  SUBLW  03
00A3:  BTFSC  03.2
00A4:  INCF   36,F
....................                 break; 
00A5:  GOTO   0AD
....................                 } 
....................             case 3: 
....................                 { 
....................                 if (NewState == 1)upState++; 
00A6:  DECFSZ 32,W
00A7:  GOTO   0A9
00A8:  INCF   35,F
....................                 if (NewState == 2)downState++;  
00A9:  MOVF   32,W
00AA:  SUBLW  02
00AB:  BTFSC  03.2
00AC:  INCF   36,F
....................                 break; 
....................                 } 
....................         };  
....................         OldState = NewState;   
00AD:  MOVF   32,W
00AE:  MOVWF  33
....................         if (upState >= 4) {  
00AF:  MOVF   35,W
00B0:  SUBLW  03
00B1:  BTFSC  03.0
00B2:  GOTO   0B6
....................             Vol+=1; 
00B3:  MOVLW  01
00B4:  ADDWF  39,F
....................             upState = 0; 
00B5:  CLRF   35
....................         }; 
....................         if (downState >= 4) {  
00B6:  MOVF   36,W
00B7:  SUBLW  03
00B8:  BTFSC  03.0
00B9:  GOTO   0BD
....................             Vol-=1; 
00BA:  MOVLW  01
00BB:  SUBWF  39,F
....................             downState = 0; 
00BC:  CLRF   36
....................         };  
....................         if (Vol > 255) Vol = 255; 
....................         if (Vol < 0) Vol = 0; 
....................      
....................     }; 
00BD:  BCF    0A.3
00BE:  GOTO   0C8 (RETURN)
....................  
.................... } 
....................  
.................... void LcdOut (void) 
.................... { 
....................       
....................      lcd_putc("\f"); 
*
0317:  CLRF   3D
0318:  MOVF   3D,W
0319:  CALL   044
031A:  IORLW  00
031B:  BTFSC  03.2
031C:  GOTO   321
031D:  INCF   3D,F
031E:  MOVWF  3E
031F:  CALL   18D
0320:  GOTO   318
....................      lcd_putc("Select num = "); 
0321:  CLRF   3D
0322:  MOVF   3D,W
0323:  CALL   04A
0324:  IORLW  00
0325:  BTFSC  03.2
0326:  GOTO   32B
0327:  INCF   3D,F
0328:  MOVWF  3E
0329:  CALL   18D
032A:  GOTO   322
....................      itoa(Vol,10,Duty); 
032B:  CLRF   41
032C:  CLRF   40
032D:  CLRF   3F
032E:  MOVF   39,W
032F:  MOVWF  3E
0330:  MOVLW  0A
0331:  MOVWF  42
0332:  MOVLW  3A
0333:  MOVWF  43
0334:  CALL   232
....................      lcd_putc(Duty[0]); 
0335:  MOVF   3A,W
0336:  MOVWF  3E
0337:  CALL   18D
....................      lcd_putc(Duty[1]); 
0338:  MOVF   3B,W
0339:  MOVWF  3E
033A:  CALL   18D
....................      lcd_putc(Duty[2]); 
033B:  MOVF   3C,W
033C:  MOVWF  3E
033D:  CALL   18D
033E:  RETURN
....................  
.................... } 
....................  
....................  
.................... void main() 
*
04B6:  MOVF   03,W
04B7:  ANDLW  1F
04B8:  MOVWF  03
04B9:  MOVLW  FF
04BA:  MOVWF  2C
04BB:  MOVLW  7F
04BC:  MOVWF  39
04BD:  BSF    03.5
04BE:  BSF    1F.0
04BF:  BSF    1F.1
04C0:  BSF    1F.2
.................... { 
....................    setup_timer_2(T2_DIV_BY_1,100,10);      //40,4 us overflow, 404 us interrupt 
*
04C3:  MOVLW  48
04C4:  MOVWF  21
04C5:  IORLW  04
04C6:  MOVWF  12
04C7:  MOVLW  64
04C8:  BSF    03.5
04C9:  MOVWF  12
....................  
....................    init_ext_eeprom(); 
04CA:  BCF    03.5
04CB:  GOTO   0CB
....................    //lcd_init(); 
....................  
....................    enable_interrupts(INT_TIMER2); 
04CC:  BSF    03.5
04CD:  BSF    0C.1
....................    enable_interrupts(GLOBAL); 
04CE:  MOVLW  C0
04CF:  BCF    03.5
04D0:  IORWF  0B,F
....................     
....................    lcd_init(); 
04D1:  GOTO   13F
....................     
....................  
....................    while(TRUE) 
....................    { 
....................       //TODO: User Code 
....................       if (Vol != OldVol) {    
04D2:  MOVF   34,W
04D3:  SUBWF  39,W
04D4:  BTFSC  03.2
04D5:  GOTO   4D9
....................           LcdOut(); 
04D6:  CALL   317
....................           OldVol = Vol; 
04D7:  MOVF   39,W
04D8:  MOVWF  34
....................         };   
....................       if(~input(PIN_A2)) 
04D9:  BSF    03.5
04DA:  BSF    05.2
04DB:  BCF    03.5
04DC:  BTFSC  05.2
04DD:  GOTO   523
....................           { 
....................               delay_ms(10); 
04DE:  MOVLW  0A
04DF:  MOVWF  42
04E0:  CALL   0D7
....................               if((~input(PIN_A2))&(~OldBtnW)) 
04E1:  BSF    03.5
04E2:  BSF    05.2
04E3:  MOVLW  00
04E4:  BCF    03.5
04E5:  BTFSS  05.2
04E6:  MOVLW  01
04E7:  MOVWF  3D
04E8:  MOVF   37,W
04E9:  XORLW  FF
04EA:  ANDWF  3D,W
04EB:  BTFSC  03.2
04EC:  GOTO   522
....................                 {   
....................                     write_ext_eeprom(0x12, Vol); 
04ED:  CLRF   3E
04EE:  MOVLW  12
04EF:  MOVWF  3D
04F0:  MOVF   39,W
04F1:  MOVWF  3F
04F2:  GOTO   3C4
....................                     lcd_putc("\f"); 
04F3:  CLRF   3D
04F4:  MOVF   3D,W
04F5:  CALL   044
04F6:  IORLW  00
04F7:  BTFSC  03.2
04F8:  GOTO   4FD
04F9:  INCF   3D,F
04FA:  MOVWF  3E
04FB:  CALL   18D
04FC:  GOTO   4F4
....................                     LcdOut(); 
04FD:  CALL   317
....................                     lcd_gotoxy(1, 2);  
04FE:  MOVLW  01
04FF:  MOVWF  3F
0500:  MOVLW  02
0501:  MOVWF  40
0502:  CALL   17B
....................                     lcd_putc("Write num = "); 
0503:  CLRF   3D
0504:  MOVF   3D,W
0505:  CALL   05C
0506:  IORLW  00
0507:  BTFSC  03.2
0508:  GOTO   50D
0509:  INCF   3D,F
050A:  MOVWF  3E
050B:  CALL   18D
050C:  GOTO   504
....................                     itoa(Vol,10,Duty); 
050D:  CLRF   41
050E:  CLRF   40
050F:  CLRF   3F
0510:  MOVF   39,W
0511:  MOVWF  3E
0512:  MOVLW  0A
0513:  MOVWF  42
0514:  MOVLW  3A
0515:  MOVWF  43
0516:  CALL   232
....................                     lcd_putc(Duty[0]); 
0517:  MOVF   3A,W
0518:  MOVWF  3E
0519:  CALL   18D
....................                     lcd_putc(Duty[1]); 
051A:  MOVF   3B,W
051B:  MOVWF  3E
051C:  CALL   18D
....................                     lcd_putc(Duty[2]);  
051D:  MOVF   3C,W
051E:  MOVWF  3E
051F:  CALL   18D
....................                     OldBtnW=1; 
0520:  MOVLW  01
0521:  MOVWF  37
....................             
....................                 };  
....................            } else 
0522:  GOTO   524
....................                {  
....................                     OldBtnW=0; 
0523:  CLRF   37
....................                };  
....................       if(~input(PIN_A3)) 
0524:  BSF    03.5
0525:  BSF    05.3
0526:  BCF    03.5
0527:  BTFSC  05.3
0528:  GOTO   56E
....................           {    
....................               delay_ms(10);     
0529:  MOVLW  0A
052A:  MOVWF  42
052B:  CALL   0D7
....................               if((~input(PIN_A3))&(~OldBtnR)) 
052C:  BSF    03.5
052D:  BSF    05.3
052E:  MOVLW  00
052F:  BCF    03.5
0530:  BTFSS  05.3
0531:  MOVLW  01
0532:  MOVWF  3D
0533:  MOVF   38,W
0534:  XORLW  FF
0535:  ANDWF  3D,W
0536:  BTFSC  03.2
0537:  GOTO   56D
....................                 {   
....................                     lcd_putc("\f"); 
0538:  CLRF   3D
0539:  MOVF   3D,W
053A:  CALL   044
053B:  IORLW  00
053C:  BTFSC  03.2
053D:  GOTO   542
053E:  INCF   3D,F
053F:  MOVWF  3E
0540:  CALL   18D
0541:  GOTO   539
....................                     LcdOut(); 
0542:  CALL   317
....................                     lcd_gotoxy(1, 2); 
0543:  MOVLW  01
0544:  MOVWF  3F
0545:  MOVLW  02
0546:  MOVWF  40
0547:  CALL   17B
....................                     lcd_putc("Read num = "); 
0548:  CLRF   3D
0549:  MOVF   3D,W
054A:  CALL   06D
054B:  IORLW  00
054C:  BTFSC  03.2
054D:  GOTO   552
054E:  INCF   3D,F
054F:  MOVWF  3E
0550:  CALL   18D
0551:  GOTO   549
....................                     itoa(read_ext_eeprom(0x12),10,Duty); 
0552:  CLRF   3E
0553:  MOVLW  12
0554:  MOVWF  3D
0555:  GOTO   40B
0556:  MOVF   21,W
0557:  MOVWF  3D
0558:  CLRF   41
0559:  CLRF   40
055A:  CLRF   3F
055B:  MOVF   21,W
055C:  MOVWF  3E
055D:  MOVLW  0A
055E:  MOVWF  42
055F:  MOVLW  3A
0560:  MOVWF  43
0561:  CALL   232
....................                     lcd_putc(Duty[0]); 
0562:  MOVF   3A,W
0563:  MOVWF  3E
0564:  CALL   18D
....................                     lcd_putc(Duty[1]); 
0565:  MOVF   3B,W
0566:  MOVWF  3E
0567:  CALL   18D
....................                     lcd_putc(Duty[2]);   
0568:  MOVF   3C,W
0569:  MOVWF  3E
056A:  CALL   18D
....................                     OldBtnR=1; 
056B:  MOVLW  01
056C:  MOVWF  38
....................                 }; 
....................           } else 
056D:  GOTO   56F
....................             { 
....................                OldBtnR=0;  
056E:  CLRF   38
....................             };         
056F:  GOTO   4D2
....................        
....................    } 
....................  
.................... } 
0570:  SLEEP

Configuration Fuses:
   Word  1: 3FB2   HS NOWDT PUT NOBROWNOUT NOPROTECT
